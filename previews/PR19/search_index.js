var documenterSearchIndex = {"docs":
[{"location":"layouts/bipartite/#Bipartite-layouts","page":"Bipartite","title":"Bipartite layouts","text":"","category":"section"},{"location":"layouts/bipartite/#Layouts","page":"Bipartite","title":"Layouts","text":"","category":"section"},{"location":"layouts/bipartite/","page":"Bipartite","title":"Bipartite","text":"BipartiteInitialLayout\nNestedBipartiteLayout","category":"page"},{"location":"layouts/bipartite/#EcologicalNetworksPlots.BipartiteInitialLayout","page":"Bipartite","title":"EcologicalNetworksPlots.BipartiteInitialLayout","text":"BipartiteInitialLayout\n\nThis type is used to generate an initial bipartite layout, where the nodes are placed on two levels, but their horizontal position is random.\n\n\n\n\n\n","category":"type"},{"location":"layouts/bipartite/#EcologicalNetworksPlots.NestedBipartiteLayout","page":"Bipartite","title":"EcologicalNetworksPlots.NestedBipartiteLayout","text":"NestedBipartiteLayout\n\nParameters are\n\nalign (whether the two levels should be centered together)\nrelative (whether the two levels should occupy a length equal to their relative richness)\nspread (the distance between the two)\n\nNote that to see the effect of spread, you may have to use aspectratio=1; if not, the spacing between levels will be determined by the dimensions of the plot.\n\n\n\n\n\n","category":"type"},{"location":"layouts/bipartite/","page":"Bipartite","title":"Bipartite","text":"using EcologicalNetworks\nusing EcologicalNetworksPlots\nusing Plots","category":"page"},{"location":"layouts/bipartite/#Example","page":"Bipartite","title":"Example","text":"","category":"section"},{"location":"layouts/bipartite/","page":"Bipartite","title":"Bipartite","text":"Unes = web_of_life(\"M_SD_033\")\nI = initial(BipartiteInitialLayout, Unes)\nposition!(NestedBipartiteLayout(0.4), I, Unes)\nplot(I, Unes, aspectratio=1)\nscatter!(I, Unes, bipartite=true)","category":"page"},{"location":"layouts/forcedirected/#Force-directed-layout","page":"Force-directed","title":"Force-directed layout","text":"","category":"section"},{"location":"layouts/forcedirected/","page":"Force-directed","title":"Force-directed","text":"FoodwebInitialLayout\nRandomInitialLayout\nForceDirectedLayout","category":"page"},{"location":"layouts/forcedirected/#EcologicalNetworksPlots.FoodwebInitialLayout","page":"Force-directed","title":"EcologicalNetworksPlots.FoodwebInitialLayout","text":"FoodwebInitialLayout\n\nThis type is used to generate an initial layout, where the nodes are placed on their trophic levels, but their horizontal position is random.\n\n\n\n\n\n","category":"type"},{"location":"layouts/forcedirected/#EcologicalNetworksPlots.RandomInitialLayout","page":"Force-directed","title":"EcologicalNetworksPlots.RandomInitialLayout","text":"RandomInitialLayout\n\nThis type is used to generate an initial layout, where the nodes are placed at random.\n\n\n\n\n\n","category":"type"},{"location":"layouts/forcedirected/#EcologicalNetworksPlots.ForceDirectedLayout","page":"Force-directed","title":"EcologicalNetworksPlots.ForceDirectedLayout","text":"ForceDirectedLayout\n\nThe fields are, in order:\n\nmove, a tuple to specify whether moves on the x and y axes are allowed\nk, a tuple giving the strength of attraction and repulsion\ngravity, the strength of attraction towards the center, set to 0.0 as a default\n\nThe spring coefficient is used to decide how strongly nodes will attract or repel one another, as a function of their distance Δ. Specifically, the default is that connected nodes will attract one another proportionally to Δ²/k, and all nodes will repel one another proportionally to k²/Δ.\n\n\n\n\n\n","category":"type"},{"location":"layouts/forcedirected/","page":"Force-directed","title":"Force-directed","text":"using EcologicalNetworks\nusing EcologicalNetworksPlots\nusing Plots","category":"page"},{"location":"layouts/forcedirected/#Bipartite-example","page":"Force-directed","title":"Bipartite example","text":"","category":"section"},{"location":"layouts/forcedirected/","page":"Force-directed","title":"Force-directed","text":"Umod = web_of_life(\"M_PA_003\")\nI = initial(RandomInitialLayout, Umod)\nfor step in 1:2000\n  position!(ForceDirectedLayout(1.5), I, Umod)\nend\nplot(I, Umod, aspectratio=1)\nscatter!(I, Umod, bipartite=true)","category":"page"},{"location":"layouts/forcedirected/#Food-web-example","page":"Force-directed","title":"Food web example","text":"","category":"section"},{"location":"layouts/forcedirected/","page":"Force-directed","title":"Force-directed","text":"Fweb = simplify(nz_stream_foodweb()[5])\nI = initial(FoodwebInitialLayout, Fweb)\nfor step in 1:4000\n  position!(ForceDirectedLayout((true, false), 2.5), I, Fweb)\nend\nplot(I, Fweb)\nscatter!(I, Fweb)","category":"page"},{"location":"examples/#Node-properties","page":"-","title":"Node properties","text":"","category":"section"},{"location":"examples/#Color","page":"-","title":"Color","text":"","category":"section"},{"location":"examples/","page":"-","title":"-","text":"Unes = web_of_life(\"M_SD_033\")\nI = initial(BipartiteInitialLayout, Unes)\nposition!(NestedBipartiteLayout(0.4), I, Unes)\nplot(I, Unes, aspectratio=1)\nscatter!(I, Unes, bipartite=true, nodefill=degree(Unes))","category":"page"},{"location":"examples/#Size","page":"-","title":"Size","text":"","category":"section"},{"location":"examples/","page":"-","title":"-","text":"The size of the nodes can be changed using the nodesize argument, which is a dictionary mapping species to values. These values are scaled when making the figures. Note that in this example we also label the number of the node.","category":"page"},{"location":"examples/","page":"-","title":"-","text":"Unes = web_of_life(\"M_SD_033\")\nI = initial(BipartiteInitialLayout, Unes)\nposition!(NestedBipartiteLayout(0.4), I, Unes)\nplot(I, Unes, aspectratio=1)\nscatter!(I, Unes, bipartite=true, nodesize=degree(Unes), series_annotations = string.(1:richness(Unes)))","category":"page"},{"location":"examples/#Network-subsets","page":"-","title":"Network subsets","text":"","category":"section"},{"location":"examples/","page":"-","title":"-","text":"One important feature of the package is that the layout can contain more nodes than the network. For example, we can use this to our advantage, to represent species with a degree larger than 3 in red:","category":"page"},{"location":"examples/","page":"-","title":"-","text":"Umod = web_of_life(\"M_PA_003\")\nI = initial(RandomInitialLayout, Umod)\nfor step in 1:4000\n  position!(ForceDirectedLayout(2.5), I, Umod)\nend\nplot(I, Umod, aspectratio=1)\nscatter!(I, Umod)\nN = convert(AbstractUnipartiteNetwork, convert(BinaryNetwork, Umod))\ncore3 = collect(keys(filter(p -> p.second == 3, degree(N))))\nplot!(I, N[core3], lc=:red)\nscatter!(I, N[core3], mc=:red)","category":"page"},{"location":"examples/#Heatmap","page":"-","title":"Heatmap","text":"","category":"section"},{"location":"examples/","page":"-","title":"-","text":"Umod = web_of_life(\"M_PA_003\")\nheatmap(Umod, c=:YlGnBu)","category":"page"},{"location":"examples/","page":"-","title":"-","text":"Umod = convert(BipartiteNetwork, web_of_life(\"M_PA_003\"))\nheatmap(convert(UnipartiteNetwork, Umod))","category":"page"},{"location":"layouts/initial/#Creating-the-initial-layout","page":"Introduction","title":"Creating the initial layout","text":"","category":"section"},{"location":"layouts/initial/","page":"Introduction","title":"Introduction","text":"The first step is to generate a starting position for the nodes in the network. In a lot of cases, this is a pseudo-random position, which is then refined. The methods for every layouts have different initial conditions.","category":"page"},{"location":"layouts/initial/","page":"Introduction","title":"Introduction","text":"initial","category":"page"},{"location":"layouts/initial/#EcologicalNetworksPlots.initial","page":"Introduction","title":"EcologicalNetworksPlots.initial","text":"initial(::Type{RandomInitialLayout}, N::T) where {T <: EcologicalNetworks.AbstractEcologicalNetwork}\n\nRandom disposition of nodes in the unit square. This is a good starting point for any force-directed layout.\n\n\n\n\n\ninitial(::Type{BipartiteInitialLayout}, N::T) where {T <: EcologicalNetworks.AbstractBipartiteNetwork}\n\nRandom disposition of nodes on two levels for bipartite networks.\n\n\n\n\n\ninitial(::Type{FoodwebInitialLayout}, N::T) where {T <: EcologicalNetworks.AbstractUnipartiteNetwork}\n\nRandom disposition of nodes on trophic levels for food webs. Note that the fractional trophic level is used, but the layout can be modified afterwards to use the continuous levels.\n\n\n\n\n\ninitial(::Type{CircularInitialLayout}, N::T) where {T <: EcologicalNetworks.AbstractEcologicalNetwork}\n\nRandom disposition of nodes on a circle. This is the starting point for circle-based layouts.\n\n\n\n\n\ninitial(::Type{UnravelledInitialLayout}, N::T) where {T <: EcologicalNetworks.AbstractUnipartiteNetwork}\n\nUnravelled disposition of nodes on trophic levels for food webs, where the x axis is the omnivory index. Note that the fractional trophic level is used, but the layout can be modified afterwards to use the continuous levels. See the documentation for UnravelledLayout to see how.\n\n\n\n\n\n","category":"function"},{"location":"layouts/initial/#Applying-the-layout","page":"Introduction","title":"Applying the layout","text":"","category":"section"},{"location":"layouts/initial/","page":"Introduction","title":"Introduction","text":"The second step is to apply the layout. In most cases, this only needs to be done once. Force-directed layouts can require a very large number of iterations, and also tend to scale very poorly with the size of the network.","category":"page"},{"location":"layouts/initial/","page":"Introduction","title":"Introduction","text":"position!","category":"page"},{"location":"layouts/initial/#EcologicalNetworksPlots.position!","page":"Introduction","title":"EcologicalNetworksPlots.position!","text":"position!(LA::ForceDirectedLayout, L::Dict{K,NodePosition}, N::T) where {T <: EcologicalNetworks.AbstractEcologicalNetwork} where {K}\n\nOne iteration of the force-directed layout routine. Because these algorithms can take some time to converge, it may be useful to stop every 500 iterations to have a look at the results.\n\n\n\n\n\nposition!(LA::LT, L::Dict{K,NodePosition}, N::T) where {LT <: UnravelledLayout, T <: AbstractEcologicalNetwork} where {K}\n\nPosition species according to the function defined in the UnravelledLayout.\n\n\n\n\n\nposition!(LA::NestedBipartiteLayout, L::Dict{K,NodePosition}, N::T) where {T <: AbstractBipartiteNetwork} where {K}\n\nRank species according to their degree.\n\n\n\n\n\nposition!(LA::CircularLayout, L::Dict{K,NodePosition}, N::T) where {T <: AbstractEcologicalNetwork} where {K}\n\nNodes will be positioned at equal distances along a circle, and nodes that are densely connected will be closer to one another. This is an efficient way to represent modular networks.\n\nReferences\n\nMcGuffin, M.J., 2012. Simple algorithms for network visualization: A tutorial. Tsinghua Science and Technology 17, 383–398. https://doi.org/10.1109/TST.2012.6297585\n\n\n\n\n\n","category":"function"},{"location":"layouts/unravelled/#Unravelled-layout","page":"-","title":"Unravelled layout","text":"","category":"section"},{"location":"layouts/unravelled/","page":"-","title":"-","text":"The unravelled layout is essentially a scatterplot of network properties with interactions drawn as well. This is inspired by the work of Giulio V. Dalla Riva on this visualisation. By default, it will compare the omnivory index and the trophic level:","category":"page"},{"location":"layouts/unravelled/#Layouts","page":"-","title":"Layouts","text":"","category":"section"},{"location":"layouts/unravelled/","page":"-","title":"-","text":"UnravelledInitialLayout\nUnravelledLayout","category":"page"},{"location":"layouts/unravelled/#EcologicalNetworksPlots.UnravelledInitialLayout","page":"-","title":"EcologicalNetworksPlots.UnravelledInitialLayout","text":"UnravelledInitialLayout\n\nThis type is used to generate an initial unravelled layout, where the nodes are sorted vertically by trophic level, and horizontally by omnivory index. Credit for this approach goes to @gvdr – https://github.com/gvdr/unravel#unravel\n\n\n\n\n\n","category":"type"},{"location":"layouts/unravelled/#EcologicalNetworksPlots.UnravelledLayout","page":"-","title":"EcologicalNetworksPlots.UnravelledLayout","text":"UnravelledLayout\n\nParameters are\n\nx (a function to get the value on x)\ny (a function to get the value on y)\n\nBoth of these functions must accept a unipartite network as input, and return a dictionary with species and a single numerical value as output. Note that x and/or y can be λs.\n\n\n\n\n\n","category":"type"},{"location":"layouts/unravelled/#Example","page":"-","title":"Example","text":"","category":"section"},{"location":"layouts/unravelled/","page":"-","title":"-","text":"N = nz_stream_foodweb()[10]\nI = initial(UnravelledInitialLayout, N)\nplot(I, N, lab=\"\", framestyle=:box)\nscatter!(I, N, nodefill=degree(N), colorbar=true, framestyle=:box)","category":"page"},{"location":"layouts/unravelled/","page":"-","title":"-","text":"Because a lot of species will have the same omnivory index, we might want to use a slightly different function, which adds some randomness to the omnivory:","category":"page"},{"location":"layouts/unravelled/","page":"-","title":"-","text":"N = nz_stream_foodweb()[10]\nI = initial(UnravelledInitialLayout, N)\n\nfunction random_omnivory(N::T) where {T <: UnipartiteNetwork}\n  o = omnivory(N)\n  for s in species(N)\n    o[s] += (rand()-0.5)*0.1\n  end\n  return o\nend\n\nUL = UnravelledLayout(x=random_omnivory, y=trophic_level)\nposition!(UL, I, N)\n\nplot(I, N, lab=\"\", framestyle=:box)\nscatter!(I, N, nodefill=degree(N), colorbar=true, framestyle=:box, mc=:viridis)","category":"page"},{"location":"","page":"Index","title":"Index","text":"The EcologicalNetworksPlots package extends EcologicalNetworks to provide plotting functionalities, by allowing network objects to be used with Plots, which must also be installed and loaded. This documentation has a complete reference of the functions and types, as well as a gallery of examples.","category":"page"},{"location":"","page":"Index","title":"Index","text":"Plotting a network can be done in two ways. First, as a heatmap, in which case no arguments are necessary. Second, as the usual nodes and links visualization.","category":"page"},{"location":"","page":"Index","title":"Index","text":"The second option requires to set a layout, of which there are multiple types according to the type of network, the type of layout, and the information to emphasize. Applying a layout consists of a call to initial, followed by one or more calls to position!. The nodes in the network are represented using scatter, and the links using plot. Probabilistic networks have link probability denoted as transparency, and quantitative network have link strength represented as width.","category":"page"},{"location":"","page":"Index","title":"Index","text":"Both the fill and color of the nodes can be changed, using the nodefill and nodesize arguments – these must be dictionaries mapping all nodes in the network to a single numerical value, and they affect the markerfill and markerz value of Plots, respectively. Note that by default, frametype is :none and legend is false, but this can be changed. It is particularly important to change it for UnravelledLayout, for example.","category":"page"},{"location":"","page":"Index","title":"Index","text":"An important point, which can be used to create complex visualisations, is that you can call the scatter and plot functions on dictionaries of positions that have more points that are in the network. This can, among other things, allow you to use different colormaps for the degree of different nodes, or color different sub-graphs in the network. There are a few example of these uses in the documentation.","category":"page"},{"location":"layouts/circular/#Circular-layout","page":"Circular","title":"Circular layout","text":"","category":"section"},{"location":"layouts/circular/#Layouts","page":"Circular","title":"Layouts","text":"","category":"section"},{"location":"layouts/circular/","page":"Circular","title":"Circular","text":"CircularInitialLayout\nCircularLayout","category":"page"},{"location":"layouts/circular/#EcologicalNetworksPlots.CircularInitialLayout","page":"Circular","title":"EcologicalNetworksPlots.CircularInitialLayout","text":"CircularInitialLayout\n\nThis type is used to generate an initial layout, where the nodes are placed at random along a circle.\n\n\n\n\n\n","category":"type"},{"location":"layouts/circular/#EcologicalNetworksPlots.CircularLayout","page":"Circular","title":"EcologicalNetworksPlots.CircularLayout","text":"CircularLayout\n\nA circular layout has a single field, radius.\n\n\n\n\n\n","category":"type"},{"location":"layouts/circular/","page":"Circular","title":"Circular","text":"using EcologicalNetworks\nusing EcologicalNetworksPlots\nusing Plots","category":"page"},{"location":"layouts/circular/#Example","page":"Circular","title":"Example","text":"","category":"section"},{"location":"layouts/circular/","page":"Circular","title":"Circular","text":"Unes = web_of_life(\"M_SD_033\")\nI = initial(CircularInitialLayout, Unes)\nposition!(CircularLayout(), I, Unes)\nplot(I, Unes, aspectratio=1)\nscatter!(I, Unes, bipartite=true)","category":"page"}]
}
